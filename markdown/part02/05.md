# Search-Based Fuzzing

> 原文：https://www.fuzzingbook.org/html/SearchBasedFuzzer.html

有时，我们不仅对fuzz 多样化输入的程序感兴趣，还希望生成特定的测试输入，以实现某些目标，例如到达程序中的特定语句。当我们知道自己在寻找什么时，我们就可以进行搜索。搜索算法是计算机科学的核心内容，但将经典的搜索算法如广度优先搜索或深度优先搜索应用于搜索测试是不现实的，因为这些算法可能需要考虑所有可能的输入。然而，领域知识可以用来克服这个问题。例如，如果我们可以估计哪个程序输入接近我们要寻找的输入，那么这些信息可以指导我们更快地达到目标 - 这些信息被称为启发式。启发式的系统应用方式包含在元启发式搜索算法中。"元"表示这些算法是通用的，并且可以针对不同的问题以不同的方式实例化。元启发式通常从观察自然界中的过程中汲取灵感。例如，有模拟进化过程、群体智能或化学反应的算法。总的来说，它们比详尽的搜索方法要高效得多，因此可以应用于广泛的搜索空间 - 就像程序输入领域一样广泛，对它们来说不是问题。

# Test Generation as a Search Problem

如果我们想要应用一个元启发式搜索算法来生成程序的测试数据，那么我们必须做出几个选择：首先，我们需要决定我们的搜索空间到底是什么。搜索空间由我们如何表示我们要寻找的内容来定义。我们是在寻找单个整数值吗？值的元组？对象？XML文档？

## Representing Program Inputs as a Search Problem

这种表示方式高度依赖于我们要解决的特定测试问题——我们知道我们正在测试哪个程序，因此表示方式需要编码为目标程序的输入。让我们以函数`test_me()`作为我们要测试的函数示例：

```c
def test_me(x, y):
    if x == 2 * (y + 1):
        return True
    else:
        return False
```

函数两个输入参数,并根据两者之间关系返回True或False

test_me()的测试输入由一对值组成，一个为x，一个为y

```c
test_me(0, 0)
>False
    
test_me(4, 2)
>False
    
test_me(22, 10)
>True
```

这个问题的搜索空间仅与输入有关，因此测试数据的简单表示形式就是输入元组`(x, y)`。 此输入空间中的每个点都有八个相邻的点：

- `x-1, y`
- `x+1, y`
- `x, y+1`
- `x, y-1`
- `x-1, y-1`
- `x-1, y+1`
- `x+1, y+1`
- `x+1, y-1`

为了简单起见，让我们限制搜索空间的大小（我们将在以后进行更改）。 例如，假设我们只需要-1000到1000范围内的值：

```c
MAX = 1000
MIN = -MAX
```

为了获取搜索空间中任何点的相邻点，我们定义了一个名为`neighbors()`的函数，它实现了基本的Moore邻域。也就是说，我们考虑了所有8个直接相邻的点，同时考虑了我们刚刚定义的MAX和MIN边界：

```c
def neighbours(x, y):
    return [(x + dx, y + dy) for dx in [-1, 0, 1]
            for dy in [-1, 0, 1]
            if (dx != 0 or dy != 0)
            and ((MIN <= x + dx <= MAX)
                 and (MIN <= y + dy <= MAX))]
```

> 通过嵌套的列表推导式生成相邻点的坐标，遍历了x和y方向上的偏移值。
>
> 计算了点(x, y)周围的8个相邻点，但排除了点(x, y)本身，同时确保生成的相邻点坐标在预定义的边界MIN和MAX之内。

```c
print(neighbors(10, 10))

>[(9, 9), (9, 10), (9, 11), (10, 9), (10, 11), (11, 9), (11, 10), (11, 11)]
```



## Defining a Search Landscape(范围): Fitness functions

所有的启发式算法都基于使用一个启发式函数，这个函数可以估算给定候选解的质量；这种“质量”通常称为个体的适应度，估算适应度的启发式函数称为适应度函数。适应度函数是一个将搜索空间中的任何点映射到数值（适应度值）的函数。候选解在搜索空间中越接近最优解，其适应度值就越好。因此，如果将搜索空间中的每个点与其适应度值作为高度绘制出来，您将得到一个以最优解表示为最高峰的地形图。

适应度函数取决于生成测试数据时希望实现的目标。假设我们有兴趣覆盖test_me()函数中的真分支，即`x == 2 * (y + 1)`。

给定的输入元组离达到目标分支有多接近呢？让我们考虑搜索空间中的任意点，例如(274, 153)。if条件比较以下值：

```c
x = 274
y = 153
x == 2 * (y + 1)
```

为了使分支正确，x和`2 * (y + 1)`的值必须相同，因此，它们之间的差异越大，我们离实现比较结果的真实性就越远；而它们之间的差异越小，我们就可以使比较结果更加真实。 因此，我们可以通过计算`x`和`2 * (y + 1)`之间的差异来量化比较的“假性”。 因此，我们可以将该距离计算为`abs(x - 2 * (y + 1))`：

```
def calculate_distance(x, y):
    return abs(x - 2 * (y + 1))

calculate_distance(274, 153)
>34
```

我们可以将这个距离值作为我们的适应度函数，因为我们可以很好地测量我们离最优解有多近。请注意，然而，这里的“更好”并不意味着“更大”；距离越小越好。这不是问题，因为任何能够最大化一个值的算法也可以被调整为最小化它。

对于整数元组的搜索空间中的每个值，这个距离值定义了我们搜索地形中的高度。由于我们的示例搜索空间是二维的，搜索地形是三维的，我们可以绘制它来看看它是什么样子的：

```c
import matplotlib.pyplot as plt
import numpy as np
%matplotlib inline

xx = np.outer(np.linspace(-10, 10, 30), np.ones(30))
yy = xx.copy().T
zz = calculate_distance(xx, yy)

fig = plt.figure()
ax = plt.axes(projection='3d')

ax.plot_surface(xx, yy, zz, cmap=plt.cm.jet, rstride=1, cstride=1, linewidth=0);
```

![image](https://github.com/kksaert/fuzzingbook/assets/83335903/627ad075-997a-4d91-b6d5-c745f47d768d)


可以看到最佳值，使if条件为真的值，其适应度值为 0，可以在图的底部清楚地看到。离最优值越远，搜索空间中的点就越高。



## Instrumentation

适应度函数应该计算具体测试执行的距离值。也就是说，我们希望运行程序，然后了解该执行的距离值。然而，分支条件隐藏在目标函数的源代码中，并且它的值原则上可能是达到它的执行路径上的各种计算的结果。即使在我们的示例中，条件是使用函数的输入值直接构成的方程，但在一般情况下，这可能并不是这样；它也可能是派生值。因此，我们需要计算距离度量所需的值需要直接在条件语句中观察到。

这通常是通过插桩来完成的：我们在分支条件之前或之后添加新代码，以跟踪观察到的值，并使用这些值来计算距离。以下是我们的测试程序的插桩版本，它在执行时打印出距离值：

```c
def test_me_instrumented(x, y):
    print("Instrumentation: Input = (%d, %d), distance = %d" %
          (x, y, calculate_distance(x, y)))
    if x == 2 * (y + 1):
        return True
    else:
        return False
```

```c
test_me_instrumented(0, 0)
>Instrumentation: Input = (0, 0), distance = 2
False

test_me_instrumented(5, 2)
>Instrumentation: Input = (5, 2), distance = 1
False

test_me_instrumented(22, 10)
>Instrumentation: Input = (22, 10), distance = 0
True
```

在计算适应度值时，我们将执行插桩后的程序版本，但我们需要一些方法来访问在执行期间计算的距离值。作为解决这个问题的简单第一步解决方案，我们可以添加一个全局变量，并将距离计算的值存储在那里。

```c
def test_me_instrumented(x, y):
    global distance
    distance = calculate_distance(x, y)
    if x == 2 * (y + 1):
        return True
    else:
        return False
```

使用这个经过插桩的test_me()版本，我们现在终于可以定义我们的适应度函数了，它只需运行经过插桩的test_me_instrumented()函数，然后检索全局距离变量的值：

```c
def get_fitness(x, y):
    global distance
    test_me_instrumented(x, y)
    fitness = distance
    return fitness
```

```
get_fitness(0, 0)
>2

get_fitness(1, 2)
>5

get_fitness(22, 10)
>0
```



## Hillclimbing the Example

在确定了表示方法（包含2个整数的元组）和适应性函数（与目标分支的距离）后，我们现在可以使用最简单的启发式算法——Hillclimbing(爬山算法)来探索这个搜索空间。这个隐喻非常贴切：该算法尝试在由我们的表示法定义的搜索空间中攀登山丘。不过，在我们的搜索景观中，最佳值并不是那些高处，而是那些低处，所以从技术上讲，我们是在下降到山谷中。

爬山算法本身非常简单：

1. 选择一个随机的起始点。
2. 计算所有相邻点的适应性值。
3. 移动到具有最佳适应性值的相邻点。
4. 如果找到解决方案，则结束；否则，继续执行步骤2。

山峰爬升器从一个随机测试输入开始，即为x和y选择随机值。对于任何一对随机整数，它们满足条件`x == 2 * (y + 1)`的机会相当渺茫。假设随机值为(274, 153)。等式的右边`2 * (y + 1)`，计算结果为308，因此条件显然为假。山峰爬升器现在应该去哪里？让我们来看看这个测试输入及其相邻点的适应性值：

```c
x, y = 274, 153
print("Origin %d, %d has fitness %d" % (x, y, get_fitness(x, y)))
for nx, ny in neighbors(x, y):
    print("neighbor %d, %d has fitness %d" % (nx, ny, get_fitness(nx, ny)))
```

```c
Origin 274, 153 has fitness 34
neighbor 273, 152 has fitness 33
neighbor 273, 153 has fitness 35
neighbor 273, 154 has fitness 37
neighbor 274, 152 has fitness 32
neighbor 274, 154 has fitness 36
neighbor 275, 152 has fitness 31
neighbor 275, 153 has fitness 33
neighbor 275, 154 has fitness 35
```

增加y会使得等式左边的值与等式右边的值之间的差异比之前之前更大！所以，增加y似乎不是一个好主意。另一方面，增加x会会改善情况：等式左边和右边的值变得更加相似；它们的"不等"程度减小了。因此，在(274, 153)的八个可能的邻点中，对(275, 152)增加x并减少y，产生的相邻点在直觉上似乎是最好的选择——条件的结果仍然为假，但比原始值更"接近"条件为真。

现在让我们实现爬山算法。

```c
import random
LOG_VALUES = 20  
def hillclimber():
    x, y = random.randint(MIN, MAX), random.randint(MIN, MAX)
    fitness = get_fitness(x, y)
    print("Initial value: %d, %d at fitness %.4f" % (x, y, fitness))
    iterations = 0
    logs = 0

    while fitness > 0:
        iterations += 1

        for (nextx, nexty) in neighbors(x, y):
            new_fitness = get_fitness(nextx, nexty)
                
            if new_fitness < fitness:
                x, y = nextx, nexty
                fitness = new_fitness
                if logs < LOG_VALUES:
                    print("New value: %d, %d at fitness %.4f" % (x, y, fitness))
                elif logs == LOG_VALUES:
                    print("...")
                logs += 1
                break

    print("Found optimum after %d iterations at %d, %d" % (iterations, x, y))
```

> 1. 首先在搜索空间中随机选择一个点(x,y)
> 2. 计算随机点的适应度值(该点距离目标分支的距离)
> 3. 在循环内部遍历 `(x, y)` 的所有邻居，即通过增加或减少 `x` 和 `y` 来生成新的点 `(nextx, nexty)`。
> 4. 如果新点的适应度值更好（更接近目标分支），则更新当前点 `(x, y)` 为新点 `(nextx, nexty)`。
> 5. 当适应度值达到零或更接近目标分支时，算法终止循环



```c
Initial value: 201, -956 at fitness 2111.0000
New value: 200, -956 at fitness 2110.0000
New value: 199, -956 at fitness 2109.0000
New value: 198, -956 at fitness 2108.0000
New value: 197, -956 at fitness 2107.0000
New value: 196, -956 at fitness 2106.0000
New value: 195, -956 at fitness 2105.0000
New value: 194, -956 at fitness 2104.0000
New value: 193, -956 at fitness 2103.0000
New value: 192, -956 at fitness 2102.0000
New value: 191, -956 at fitness 2101.0000
New value: 190, -956 at fitness 2100.0000
New value: 189, -956 at fitness 2099.0000
New value: 188, -956 at fitness 2098.0000
New value: 187, -956 at fitness 2097.0000
New value: 186, -956 at fitness 2096.0000
New value: 185, -956 at fitness 2095.0000
New value: 184, -956 at fitness 2094.0000
New value: 183, -956 at fitness 2093.0000
New value: 182, -956 at fitness 2092.0000
New value: 181, -956 at fitness 2091.0000
...
Found optimum after 1656 iterations at -1000, -501
```

爬山算法开始于选择x和y的随机值。我们在示例中使用了较小的值范围，介于 -1000 到 1000 之间（这些范围之前已经定义为 MIN 和 MAX），以减少执行搜索所需的时间

然后，通过调用 get_fitness() 函数来确定此起始点的适应度值。请注意，我们试图找到最小可能的适应度值，因此我们现在循环执行，直到找到适应度值为 0 的点（即最优点）。

在这个循环中，我们遍历所有邻居点，并评估每个邻居点的适应度值。一旦我们找到一个具有更好（更小）适应度值的邻居点，山峰爬升算法退出循环，并使用此邻居点作为新的起始点。

还有一个这个简单山峰爬升算法的替代变体，可以删除 break 语句：这样做的话，将会评估所有邻居点，选择适应度最佳的邻居点。这被称为"最陡爬山算法"。

```c
def steepest_ascent_hillclimber():
    x, y = random.randint(MIN, MAX), random.randint(MIN, MAX)
    fitness = get_fitness(x, y)
    print("Initial value: %d, %d at fitness %.4f" % (x, y, fitness))
    iterations = 0
    logs = 0

    while fitness > 0:
        iterations += 1
        for (nextx, nexty) in neighbors(x, y):
            new_fitness = get_fitness(nextx, nexty)
            if new_fitness < fitness:
                x, y = nextx, nexty
                fitness = new_fitness
                if logs < LOG_VALUES:
                    print("New value: %d, %d at fitness %.4f" % (x, y, fitness))
                elif logs == LOG_VALUES:
                    print("...")
                logs += 1

    print("Found optimum after %d iterations at %d, %d" % (iterations, x, y))
```

```c
Initial value: -258, 645 at fitness 1550.0000
New value: -259, 644 at fitness 1549.0000
New value: -258, 644 at fitness 1548.0000
New value: -257, 644 at fitness 1547.0000
New value: -258, 643 at fitness 1546.0000
New value: -257, 643 at fitness 1545.0000
New value: -256, 643 at fitness 1544.0000
New value: -257, 642 at fitness 1543.0000
New value: -256, 642 at fitness 1542.0000
New value: -255, 642 at fitness 1541.0000
New value: -256, 641 at fitness 1540.0000
New value: -255, 641 at fitness 1539.0000
New value: -254, 641 at fitness 1538.0000
New value: -255, 640 at fitness 1537.0000
New value: -254, 640 at fitness 1536.0000
New value: -253, 640 at fitness 1535.0000
New value: -254, 639 at fitness 1534.0000
New value: -253, 639 at fitness 1533.0000
New value: -252, 639 at fitness 1532.0000
New value: -253, 638 at fitness 1531.0000
New value: -252, 638 at fitness 1530.0000
...
Found optimum after 517 iterations at 258, 128
```

我们的示例程序具有非常好的适应度景观 - 存在完美的梯度，而且山地爬升算法总是能够找到解决方案。如果我们绘制随时间观察到的适应度值，我们可以看到这个漂亮的梯度。

```c
def plotting_hillclimber(fitness_function):
    data = []

    # Create and evaluate starting point
    x, y = random.randint(MIN, MAX), random.randint(MIN, MAX)
    fitness = fitness_function(x, y)
    data += [fitness]
    iterations = 0

    # Stop once we have found an optimal solution
    while fitness > 0:
        iterations += 1
        # Move to first neighbor with a better fitness
        for (nextx, nexty) in neighbors(x, y):
            new_fitness = fitness_function(nextx, nexty)
            if new_fitness < fitness:
                x, y = nextx, nexty
                fitness = new_fitness
                data += [fitness]
                break

    print("Found optimum after %d iterations at %d, %d" % (iterations, x, y))
    return data
```



```c
def plotting_hillclimber(fitness_function):
    data = []

    # Create and evaluate starting point
    x, y = random.randint(MIN, MAX), random.randint(MIN, MAX)
    fitness = fitness_function(x, y)
    data += [fitness]
    iterations = 0

    # Stop once we have found an optimal solution
    while fitness > 0:
        iterations += 1
        # Move to first neighbor with a better fitness
        for (nextx, nexty) in neighbors(x, y):
            new_fitness = fitness_function(nextx, nexty)
            if new_fitness < fitness:
                x, y = nextx, nexty
                fitness = new_fitness
                data += [fitness]
                break

    print("Found optimum after %d iterations at %d, %d" % (iterations, x, y))
    return data
```

![image](https://github.com/kksaert/fuzzingbook/assets/83335903/f8312caf-52e0-4b7e-9f67-2f3b3b8de5cf)


这个梯度是理想适应度景观的结果。实际上，我们并不总是拥有如此理想的梯度。特别是，我们的山地爬升算法只有在至少有一个邻居具有更好的适应度值时才能正常工作。如果我们达到一个没有邻居实际上具有更好适应度值的点会怎么样呢？考虑以下函数 test_me2：

```c
def test_me2(x, y):
    if(x * x == y * y * (x % 20)):
        return True
    else:
        return False
```

如果我们想再次覆盖`test_me2`中if条件的真分支，那么我们可以采用与以前相同的方式来计算距离，即通过计算比较两侧之间的差异。 

```c
def test_me2_instrumented(x, y):
    global distance
    distance = abs(x * x - y * y * (x % 20))
    if(x * x == y * y * (x % 20)):
        return True
    else:
        return False
```

再写一个适应性函数:

```c
def bad_fitness(x, y):
    global distance
    test_me2_instrumented(x, y)
    fitness = distance
    return fitness
```

绘制图来看看搜索空间

```c
xx = np.outer(np.linspace(-10, 10, 30), np.ones(30))
yy = xx.copy().T
zz = abs(xx * xx - yy * yy * (xx % 20))
fig = plt.figure()
ax = plt.axes(projection='3d')

ax.plot_surface(xx, yy, zz, cmap=plt.cm.jet, rstride=1, cstride=1, linewidth=0);
```

![image](https://github.com/kksaert/fuzzingbook/assets/83335903/ca6ffa68-78cd-4ac3-b651-d77ae5e1d5d4)


此时使用新的适应度函数运行山地爬升算法，但存在问题：使用此适应度函数运行我们的山地爬升算法并不是一个好主意，因为它可能永远不会终止。假设我们已经到达一个所有邻居具有相同或更差适应度值的点。山地爬升算法将无法移动，会永远卡在那里！在搜索景观中的这种点称为局部最优解。如果到达这种点，最简单的方法是放弃，并从新的随机点重新开始。这就是我们将在具有随机重启的山地爬升算法中执行的操作。

```c
def restarting_hillclimber(fitness_function):
    data = []

    # Create and evaluate starting point
    x, y = random.randint(MIN, MAX), random.randint(MIN, MAX)
    fitness = fitness_function(x, y)
    data += [fitness]
    print("Initial value: %d, %d at fitness %.4f" % (x, y, fitness))
    iterations = 0


    while fitness > 0:
        changed = False
        iterations += 1
        for (nextx, nexty) in neighbors(x, y):
            new_fitness = fitness_function(nextx, nexty)
            if new_fitness < fitness:
                x, y = nextx, nexty
                fitness = new_fitness
                data += [fitness]
                changed = True
                break
        if not changed:
            x, y = random.randint(MIN, MAX), random.randint(MIN, MAX)
            fitness = fitness_function(x, y)
            data += [fitness]

    print("Found optimum after %d iterations at %d, %d" % (iterations, x, y))
    return data
```

当适应度没有改变时重新随机生成新的点进行计算。

这个改变非常简单：我们只是使用一个布尔标志来跟踪是否发生了移动，如果我们没有移动到任何邻居处，就会随机选择一个新的起始位置重新开始搜索。为了方便起见，我们还使得爬山算法可接受适应度函数作为参数。现在，让我们尝试使用名为`bad_fitness`的适应度函数，并绘制我们观察到的适应度值的图表。

```c
MAX = 1000
MIN = -MAX
data = restarting_hillclimber(bad_fitness)

>Initial value: 333, 231 at fitness 582804.0000
Found optimum after 165 iterations at 521, 521
```

```c
import matplotlib.pyplot as plt
fig = plt.figure()
ax = plt.axes()

xs = range(len(data))
ax.plot(xs, data);
```

![image](https://github.com/kksaert/fuzzingbook/assets/83335903/bd119b02-5849-45b1-b642-093a2789a767)






运行这个示例几次。有时，我们会很幸运，找到了一条通向最优解的路径。但有时，你会看到在搜索过程中出现了多次重新启动，然后才找到最优解。

我们将x和y的初始值限制在了一个相当小的范围内，即[MIN, MAX]。这是测试生成中的一种常见技巧，因为在大多数情况下，解往往由较小的值组成，使用小值来开始搜索在许多情况下可以加快搜索速度。但是，如果我们需要的解位于搜索空间中的完全不同位置怎么办？我们对较小解的偏好意味着爬山算法可能需要很长时间才能找到解决方案，而且在固定的搜索预算内，它可能不太可能真正找到解决方案。为了查看这将产生什么影响，我们可以简单地将1000替换为更大的值，比如1000000或更多。我们可以尝试不同的范围来查看对于我们的简单搜索问题，我们会获得什么性能。

```
MAX = 100000
MIN = -MAX

from Timer import Timer
with Timer() as t:
    restarting_hillclimber(get_fitness)
    print("Search time: %.2fs" % t.elapsed_time())

>Initial value: 64543, -55357 at fitness 175255.0000
Found optimum after 169899 iterations at -100000, -50001
Search time: 0.39s
```

在大多数情况下，搜索将需要更长的时间才能找到解决方案，比这样一个简单的示例函数等待的时间更长！（尽管有时我们会很幸运，随机命中一个良好的起始位置）。这如何能够在“真实”的示例上工作呢？更不用说如果有更多参数和更大的邻域的情况下！



# Testing a More Complex Program

测试一个更复杂的程序，之前[the Coverage chapter](https://www.fuzzingbook.org/html/Coverage.html).中的CGI解码函数

```
def cgi_decode(s):
    hex_values = {
        '0': 0, '1': 1, '2': 2, '3': 3, '4': 4,
        '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,
        'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 'f': 15,
        'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15,
    }

    t = ""
    i = 0
    while i < len(s):
        c = s[i]
        if c == '+':
            t += ' '
        elif c == '%':
            digit_high, digit_low = s[i + 1], s[i + 2]
            i += 2
            if digit_high in hex_values and digit_low in hex_values:
                v = hex_values[digit_high] * 16 + hex_values[digit_low]
                t += chr(v)
            else:
                raise ValueError("Invalid encoding")
        else:
            t += c
        i += 1
    return t
```

## CGI Decoder as a Search Problem

`cgi_decode()`函数具有一个类型为string的输入，并且定义字符串邻域的一种可能方式是编辑距离为1的所有可能的字符串。例如，字符串`test`的每个字母具有两个邻居。 

- `uest`
- `tfst`
- `tett`
- `tesu`
- `sest`
- `tdst`
- `tert`
- `tess`

> 单词的每一个字母，替换为该字母的前一个或后一个

此外，在任何字符之前或之后添加任何字符也将具有1的编辑距离，并且可以将其视为邻居。 为简单起见，让我们将输入字符串的长度固定为合理的值（例如10）。 在这种情况下，每个输入有20个邻居（即每个字符有两个邻居）。

实现一个新的`neighbour_strings()`函数，该函数生成这些相邻的字符串：

```c
def neighbour_strings(x):
    n = []
    for pos in range(len(x)):
        c = ord(x[pos])
        if c < 127:
            n += [x[:pos] + chr(c + 1) + x[pos + 1:]]
        if c > 20:
            n += [x[:pos] + chr(c - 1) + x[pos + 1:]]
    return n
```

`neighbour_strings()`函数获取输入字符串中每个字符的数值，并创建一个新字符串，并用字母中的前一个和后继字符替换该字符。 首先，我们仅考虑可打印的ASCII字符，范围为20--127。

```c
print(neighbor_strings("Hello"))

>['Iello', 'Gello', 'Hfllo', 'Hdllo', 'Hemlo', 'Heklo', 'Helmo', 'Helko', 'Hellp', 'Helln']
```

## Branch Distances

`test_me()`函数由单个if条件组成，其中比较了两个整数。 在`cgi_decode()`函数中，我们具有三个if条件和一个while循环，它们都比较字符。 幸运的是，正如我们已经看到的，我们可以将字符视为数字，因此我们可以使用在`test_me()`示例中使用的相同距离估计。 但是，还有两个条件可以检查字符是否包含在集合中，例如： `digit_high in hex_values`。 集合中包含的值接近多少？ 一个明显的解决方案是将与集合中最接近的值的距离视为估计值。

```python
import sys
def distance_character(target, values):

    minimum = sys.maxsize #系统支持的最大整数值的常量

    for elem in values:
        distance = abs(target - elem)
        if distance < minimum:
            minimum = distance
    return minimum

distance_character(10, [1, 5, 12, 100])
>2
distance_character(10, [0, 50, 80, 200])
>10
```

> 计算 `target` 与 `values` 中的每个元素之间的绝对差距，然后返回这些差距中的最小值。

到目前为止，我们所做的另一个简化是假设我们总是希望条件求值为 true。在实践中，我们可能希望if条件求值为 false。因此，每个 if 条件实际上都有两个距离估计，一个用于估计它离真值有多接近，另一个用于估计它离假值有多接近。如果条件为真，则真实距离为 0；如果条件为假，则假距离为 0。也就是说，在比较 a == b 时，如果 a小于b，那么根据定义，假距离为 0。

当 a 等于 b 时，a == b 为 false 时的距离是多少？对a或b中的任何一个进行更改都将导致条件为 false，因此在这种情况下，我们可以简单地将距离定义为 1。

更一般地说，还可以有其他类型的比较，例如使用关系运算符。考虑cgi_decode()中的循环条件：i < len(s)，即它使用了一个小于比较运算符。很容易扩展我们的分支距离概念，以涵盖不同类型的比较，并计算真实距离和假距离。以下表格显示了如何计算不同类型比较的距离：

| Condition | Distance True | Distance False |
| :-------- | :-----------: | -------------: |
| a == b    |  abs(a - b)   |              1 |
| a != b    |       1       |     abs(a - b) |
| a < b     |   b - a + 1   |          a - b |
| a <= b    |     b - a     |      a - b + 1 |
| a > b     |   a - b + 1   |          b - a |

请注意，其中一些计算都加了一个常数 1。这背后的原因非常简单：假设我们希望 a < b 求值为 true，并且让 a = 27，b = 27。条件不为 true，但仅仅计算差异会给我们一个结果为 0。为了避免这种情况，我们必须添加一个常数值。重要的是这个值是否为 1，任何正数常数都可以。

## Dealing with Complex Conditions


在 `cgi_decode()` 函数中，我们还可以找到一个稍微复杂的谓词，由两个逻辑与连接的条件组成：

```python
if digit_high in hex_values and digit_low in hex_values:
```

原则上，将分支距离定义为使得使连词`A and B`为真的距离等于`A`和`B`的分支距离之和，因为两个条件都必须为真。 同样，使`A or B`为真的分支距离将为`A`和`B`的两个分支距离中的最小值，因为如果两个条件之一为真就可以使整个表达式为真。

但是，这并不像在实践中那样容易：谓词可以由嵌套条件和否定组成，并且在应用此计算之前，需要将表达式转换为规范形式。 此外，大多数现代编程语言都使用*短路评估*：如果存在条件`A or B`且`A`为true，则永远不会评估`B`。 如果`B`是带有副作用的表达式，那么即使短路评估会避免执行`B`的分支距离，也可以通过计算`B`的分支距离，来潜在地改变程序的行为（通过调用会导致副作用的副作用） 在正常行为中不执行），那是不可接受的。

此外，如果分支条件有副作用怎么办？ 例如，假设分支条件为`x == 2 * foo(y)`，其中`foo()`是采用整数作为输入的函数。 幼稚的检测将导致以下代码：

```
codedistance = abs(x - 2 * foo(y))
if x == 2 * foo(y):
    ...
```

因此，插桩会导致 `foo()` 被执行两次。假设 `foo()` 更改了系统的状态（例如，通过打印内容，访问文件系统，更改某些状态变量等），显然再次调用 `foo()` 是一个不好的主意。解决这个问题的一种方法是转换条件，而不是添加跟踪调用。例如，可以创建临时变量，保存距离计算所需的值，然后在分支条件中使用这些变量：

```
pythonCopy codetmp1 = x
tmp2 = 2 * foo(y)
distance = abs(tmp1 - tmp2)
if tmp1 == tmp2:
    ...
```

除了这些问题，向程序添加全局变量和方法调用似乎是一种相当笨拙的方法，当然，我们不能开始单独考虑程序中的每个分支，并手动插桩要测试的程序，特别是如果程序有多个类似 `cgi_decode()` 函数的分支。相反，我们应该研究如何自动插桩程序，以包含必要的附加语句，以便我们可以计算适应度值。

## Instrumentation for Atomic Conditions

一个替代使用全局变量和临时变量的方法是将实际比较替换为对辅助函数的调用，该函数将原始表达式作为参数求值，而运算符是一个附加参数。 假设我们有一个函数`evaluate_condition()`，它带有四个参数：

- `num` 是唯一标识条件的 ID；
- `op` 是比较的运算符；
- `lhs` 和 `rhs` 是操作数。

该函数计算条件的两个距离：使条件为真的距离和使条件为假的距离。两种结果中的一种将始终为真，因此其中一种将始终具有距离为 0。由于该函数替换了原始比较，它返回 true 或 false，具体取决于哪个距离为 0。这意味着，例如，原始表达式：

```
if x == 2 * foo(y)
```

将被替换为：

```
if evaluate_condition(0, "Eq", x, 2 * foo(y))
```

这样，参数仅被评估一次，因此副作用得到正确处理。以下是 `evaluate_condition()` 函数的示例实现：

```c
def evaluate_condition(num, op, lhs, rhs):
    distance_true = 0
    distance_false = 0
    if op == "Eq":
        if lhs == rhs:
            distance_false = 1
        else:
            distance_true = abs(lhs - rhs)

    # ... code for other types of conditions

    if distance_true == 0:
        return True
    else:
        return False
```

请注意，我们正在使用`0`初始化`distance_true`和`distance_false`。 因此，如果`lhs`等于`rhs`，则变量`distance_true`保持为0，反之亦然

```c
evaluate_condition(1, "Eq", 10, 20)
>False

evaluate_condition(2, "Eq", 20, 20)
>True
```

`evaluate_condition()` 函数目前还没有做的事情是存储观察到的距离值。显然，我们需要将这些值存储在某个地方，以便我们可以从我们的适应度函数中访问它。由于 `cgi_decode()` 程序由多个条件组成，对于每个条件，我们可能对真值和假值都感兴趣，因此我们简单地使用两个全局字典，`distances_true` 和 `distances_false`，并定义一个辅助函数，将观察到的距离值存储在字典

```c
def update_maps(condition_num, d_true, d_false):
    global distances_true, distances_false

    if condition_num in distances_true.keys():
        distances_true[condition_num] = min(
            distances_true[condition_num], d_true)
    else:
        distances_true[condition_num] = d_true

    if condition_num in distances_false.keys():
        distances_false[condition_num] = min(
            distances_false[condition_num], d_false)
    else:
        distances_false[condition_num] = d_false
```

变量`condition_num`是我们刚刚评估的条件的唯一ID。 如果这是我们第一次执行此特定条件，则将正确和错误的距离简单地存储在相应的字典中。 但是，同一测试有可能多次执行条件。 例如，`cgi_decode()`函数中的循环条件`i < len(s)`在每个单循环迭代之前进行评估。 但是，最后，我们希望为测试提供一个适合度值。 由于覆盖分支仅要求至少有一个执行到达分支，因此我们仅考虑最接近的一个。 因此，如果`distances_true`和`distances_false`字典已经包含与上一个执行程序的距离，则仅当新的执行程序更接近分支时才替换该值；否则，将替换该值。 这是使用`min()`功能实现的。

现在，我们需要从`evaluate_condition()`中调用此函数。 我们还要为`in`运算符和`<`比较添加距离计算，因为在`cgi_decode()`示例中我们都需要它们。 此外，`cgi_decode()`实际上比较字符和数字。 为了确保使用正确的类型，我们首先必须将字符转换为数字以计算距离。 这是使用Python的`ord()`函数完成的。

```c
def evaluate_condition(num, op, lhs, rhs):
    distance_true = 0
    distance_false = 0

    # Make sure the distance can be calculated on number and character
    # comparisons
    if isinstance(lhs, str):
        lhs = ord(lhs)
    if isinstance(rhs, str):
        rhs = ord(rhs)

    if op == "Eq":
        if lhs == rhs:
            distance_false = 1
        else:
            distance_true = abs(lhs - rhs)

    elif op == "Lt":
        if lhs < rhs:
            distance_false = rhs - lhs
        else:
            distance_true = lhs - rhs + 1
    # ...
    # handle other comparison operators
    # ...

    elif op == "In":
        minimum = sys.maxsize
        for elem in rhs.keys():
            distance = abs(lhs - ord(elem))
            if distance < minimum:
                minimum = distance

        distance_true = minimum
        if distance_true == 0:
            distance_false = 1

    update_maps(num, distance_true, distance_false)

    if distance_true == 0:
        return True
    else:
        return False
```

以下是对来自 `cgi_decode()` 的逻辑与条件进行插桩，以利用 `evaluate_condition()` 函数的示例。有两个对 `evaluate_condition` 的调用，分别对应于两个条件，而使用 `and` 连接符将它们连接起来，以确保原始的短路行为被保留：

```c
if (evaluate_condition(4, 'In', digit_high, hex_values) and evaluate_condition(5, 'In', digit_low, hex_values))
```

当然，我们希望能够自动生成这种插桩的代码。

## Instrumenting Source Code Automatically

实际上，使用程序的抽象语法树（AST）在Python中自动替换比较非常容易。 在AST中，比较通常是一个树节点，该节点具有一个运算符属性，两个运算符分别用于左手运算符和右手运算符。 要用对`evaluate_condition()`的调用替换此类比较，只需将AST中的比较节点替换为函数调用节点，这就是`BranchTransformer`类使用Python的`ast`模块中的NodeTransformer所做的事情：

```c
import ast
class BranchTransformer(ast.NodeTransformer):

    branch_num = 0

    def visit_FunctionDef(self, node):
        node.name = node.name + "_instrumented"
        return self.generic_visit(node)

    def visit_Compare(self, node):
        if node.ops[0] in [ast.Is, ast.IsNot, ast.In, ast.NotIn]:
            return node

        self.branch_num += 1
        return ast.Call(func=ast.Name("evaluate_condition", ast.Load()),
                        args=[ast.Num(self.branch_num),
                              ast.Str(node.ops[0].__class__.__name__),
                              node.left,
                              node.comparators[0]],
                        keywords=[],
                        starargs=None,
                        kwargs=None)
```

`BranchTransformer`使用内置解析器`ast.parse()`解析目标Python程序，该解析器返回AST。 Python提供了用于遍历和修改此AST的API。 为了用函数调用代替比较，我们使用`ast.NodeTransformer`，它使用访问者模式，其中AST中每种类型的节点都有一个`visit_*`函数。 因为我们有兴趣替换比较，所以我们覆盖了`visit_Compare`，在这里，我们返回了一个类型为`ast.Func`的新节点，而不是原始的比较节点，这是一个函数调用节点。 该节点的第一个参数是函数`evaluate_condition()`的名称，参数是我们的`evaluate_condition()`函数所期望的四个参数：

- 分支的数量（我们将其保留在`branch_num`中），
- 运算符（我们只使用其类名），
- 左侧，以及
- 右边。

请注意，Python允许比较多个表达式（例如`1 < x < 10`）； 为了使代码保持简单，我们在这里仅处理单个比较，但是通过将每个比较与对`evaluate_condition`的单独调用进行处理，可以扩展代码。 您会注意到，我们还覆盖了`visit_FunctionDef`； 这只是通过添加`_instrumented`来更改方法的名称，以便我们可以继续将原始功能与已检测的功能一起使用。

以下代码将`cgi_decode()`函数的源代码解析为AST，然后对其进行转换，然后再次打印出来（使用`astor`库中的`to_source()`函数）：

```c
import inspect
import ast
from bookutils import print_content
source = inspect.getsource(cgi_decode)
node = ast.parse(source)
BranchTransformer().visit(node)

# Make sure the line numbers are ok before printing
node = ast.fix_missing_locations(node)
print_content(ast.unparse(node), '.py')
def cgi_decode_instrumented(s):
    """Decode the CGI-encoded string `s`:
       * replace "+" by " "
       * replace "%xx" by the character with hex number xx.
       Return the decoded string.  Raise `ValueError` for invalid inputs."""
    hex_values = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 'f': 15, 'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15}
    t = ''
    i = 0
    while evaluate_condition(1, 'Lt', i, len(s)):
        c = s[i]
        if evaluate_condition(2, 'Eq', c, '+'):
            t += ' '
        elif evaluate_condition(3, 'Eq', c, '%'):
            (digit_high, digit_low) = (s[i + 1], s[i + 2])
            i += 2
            if evaluate_condition(4, 'In', digit_high, hex_values) and evaluate_condition(5, 'In', digit_low, hex_values):
                v = hex_values[digit_high] * 16 + hex_values[digit_low]
                t += chr(v)
            else:
                raise ValueError('Invalid encoding')
        else:
            t += c
        i += 1
    return t
```

要使用插桩版本计算适应度值，我们需要再次编译插桩的AST，这是通过使用Python的`compile()`函数完成的。然后，我们需要使编译后的函数可访问。首先，我们从`sys.modules`中获取当前模块，然后使用`exec`将插桩函数的编译代码添加到当前模块的函数列表中。完成后，就可以访问`cgi_decode_instrumented()`函数。

```c
def create_instrumented_function(f):
    source = inspect.getsource(f)
    node = ast.parse(source)
    node = BranchTransformer().visit(node)

    node = ast.fix_missing_locations(node)

    current_module = sys.modules[__name__]
    code = compile(node, filename="<ast>", mode="exec")
    exec(code, current_module.__dict__)
```

```
from typing import Dict
distances_true: Dict[int, int] = {}
distances_false: Dict[int, int] = {}
create_instrumented_function(cgi_decode)
assert cgi_decode("Hello+Reader") == cgi_decode_instrumented("Hello+Reader")

>cgi_decode_instrumented("Hello+Reader")
'Hello Reader'

>distances_true
{1: 0, 2: 0, 3: 35}

>distances_false
{1: 0, 2: 0, 3: 0}
```

从`distances_true`和`distances_false`映射中可以看出，条件1和2在`cgi_decode_instrumented`上执行时已评估为true和false，而条件3仅已评估为false。 这是预期的，因为进入并离开了while循环，并且输入字符串中只有一个空格，但没有`%`-字符。

## Fitness Function to Create Valid Hexadecimal Inputs

作为一个示例，让我们以测试 `cgi_decode()` 的一部分，即解码有效的十六进制代码，作为目标。这意味着我们希望让条件1为真，条件2为假，条件3为真，条件4为真。要表示这样一条路径，我们可以简单地将正好这些条件的分支距离相加。然而，简单地将分支距离相加可能存在潜在问题：如果一个条件的距离取决于非常大的值的比较，而另一个条件的距离计算取决于小值，那么改进大值很可能会导致更好的适应度改进，从而偏向搜索结果。为了避免这种情况，我们需要在将它们相加之前对分支距离进行标准化。

一个用于范围[a, b] 的标准化函数接受一个数字作为输入，并返回一个值，该值>=a 且 <=b。关于这个函数的重要事情是，对于任何两个数字 x 和 y，标准化后的值的顺序必须保持不变。也就是说，如果 x<y，则必须保持 normalize(x) < normalize(y)。有许多不同的函数可以实现这个结果；一个简单的函数是 normalize(x) = x/(x+k)：它计算成本低廉，将任何正值标准化到范围 [0,1] 内（要将其更改为 [0, b]，只需乘以 b）。如果我们使用这个标准化函数，我们还知道最大值：它是 1.0。该函数假定要标准化的值是正值。因子 k 的值定义了曲线的陡峭程度。例如，对于 k=1（这是一个很好的默认值），曲线非常陡峭，值迅速接近但永远不会达到 1。

```c
def normalize(x):
    return x / (1.0 + x)
```

要查看此归一化函数的工作方式，我们可以绘制一系列值。 x轴包含原始值，y轴显示相应的归一化值：

```c
import matplotlib.pyplot as plt
fig = plt.figure()
ax = plt.axes()

xs = range(100)
ys = [value / (value + 1.0) for value in xs]
ax.plot(xs, ys);
```

![image](https://github.com/kksaert/fuzzingbook/assets/83335903/2066c750-8d23-43ce-94e7-dea387ac9cc9)


使用此归一化功能，我们可以通过运行被测程序程序，然后将相关分支的归一化值相加来计算适应度值。 但是，并不是每个测试用例都会执行每个if语句。 什至没有执行的分支的分支距离是多少？ 我们需要确保甚至没有执行的分支的分支距离都大于执行期间观察到的任何分支距离。 给定归一化后，我们知道该最大值为1。因此，适应度函数可能如下所示：

```c
def get_fitness(x):
    # Reset any distance values from previous executions
    global distances_true, distances_false
    distances_true = {}
    distances_false = {}

    # Run the function under test
    try:
        cgi_decode_instrumented(x)
    except BaseException:
        pass

    # Sum up branch distances
    fitness = 0.0
    for branch in [1, 3, 4, 5]:
        if branch in distances_true:
            fitness += normalize(distances_true[branch])
        else:
            fitness += 1.0

    for branch in [2]:
        if branch in distances_false:
            fitness += normalize(distances_false[branch])
        else:
            fitness += 1.0

    return fitness
```

```
get_fitness_cgi("")
>4.5

# String contains no percentage character
get_fitness_cgi("Hello+Reader")
>2.9722222222222223

# String contains a percentage character, but no valid hex char
get_fitness_cgi("%UU")
>1.9230769230769231

# String contains a percentage character, but only one valid hex char
get_fitness_cgi("%AU")
>0.9230769230769231

# String contains a percentage character and two valid hex chars
get_fitness_cgi("%AA")
>0.0
```

## Hillclimbing Valid Hexadecimal Inputs

现在，我们已经通过`neighbour_strings()`函数定义了搜索空间，并且派生了一个新的适应度函数，因此在将hillclimber应用到查找包含有效两位数十六进制代码的字符串的问题之前，剩下的唯一点是得出一个随机的起点，已经在 [MutationFuzzer章节](https://github.com/apachecn/fuzzingbook-zh/blob/master/docs/MutationFuzzer.html)中进行了此操作：

```c
def random_string(l):
    s = ""
    for i in range(l):
        random_character = chr(random.randrange(32, 127))
        s = s + random_character
    return s
```

现在我们可以将它们放在一起，再次使用相同的爬山算法，只是使其生成随机字符串而不是数字，并使用新的适应性函数：

```c
def hillclimb_cgi():
    x = random_string(10)
    fitness = get_fitness(x)
    print("Initial input: %s at fitness %.4f" % (x, fitness))

    while fitness > 0:
        changed = False
        for (nextx) in neighbour_strings(x):
            new_fitness = get_fitness(nextx)
            if new_fitness < fitness:
                x = nextx
                fitness = new_fitness
                changed = True
                print("New value: %s at fitness %.4f" % (x, fitness))
                break

        # Random restart if necessary
        if not changed:
            x = random_string(10)
            fitness = get_fitness(x)

    print("Optimum at %s, fitness %.4f" % (x, fitness))
```

```c
hillclimb_cgi()
>Initial input: o'@[3(rW*M at fitness 2.6667
New value: o&@[3(rW*M at fitness 2.5000
New value: o%@[3(rW*M at fitness 1.5000
New value: o%A[3(rW*M at fitness 0.8571
New value: o%A\3(rW*M at fitness 0.8333
New value: o%A]3(rW*M at fitness 0.8000
New value: o%A^3(rW*M at fitness 0.7500
New value: o%A_3(rW*M at fitness 0.6667
New value: o%A`3(rW*M at fitness 0.5000
New value: o%Aa3(rW*M at fitness 0.0000
Optimum at o%Aa3(rW*M, fitness 0.0000
```

运行hillclimber多次，以查看它生成带有有效十六进制字符的字符串。 有时只需要几个步骤，有时就需要更长的时间，但是最后它总是可以解决问题并生成我们想要的字符串。

## Evolutionary Search

如果邻里很小，爬山的效果很好。 到目前为止，在`cgi_decode()`示例中就是这种情况，因为我们将自己限制为固定数量的字符（10），并将字符范围限制为可打印的ASCII字符。 但是想象一下，如果我们不寻找ASCII字符，而是寻找UTF-16 Unicode字符，会发生什么？ 确实不允许在URL中使用它们，但是让我们看看如果更改搜索空间会发生什么：

```c
def random_unicode_string(l):
    s = ""
    for i in range(l):
        # Limits to reflect range of UTF-16
        random_character = chr(random.randrange(0, 65536))
        s = s + random_character
    return s
```

```c
def unicode_string_neighbours(x):
    n = []
    for pos in range(len(x)):
        c = ord(x[pos])
        # Limits to reflect range of UTF-16
        if c < 65536:
            n += [x[:pos] + chr(c + 1) + x[pos + 1:]]
        if c > 0:
            n += [x[:pos] + chr(c - 1) + x[pos + 1:]]

    return n
```

UTF-8字符用16位表示，这为我们提供了65536个可能的字符范围。 以上功能适用于这些边界。 在再次运行爬坡器之前，让我们再做一个更改：我们将添加一个迭代限制，以便我们可以放弃搜索，而不是永远等待搜索完成。

```c
def terminal_repr(s):
    return terminal_escape(repr(s))

def hillclimb_cgi_limited(max_iterations):
    x = random_unicode_string(10)
    fitness = get_fitness(x)
    print("Initial input: %s at fitness %.4f" % (terminal_repr(x), fitness))

    iteration = 0
    logs = 0
    while fitness > 0 and iteration < max_iterations:
        changed = False
        for (nextx) in unicode_string_neighbours(x):
            new_fitness = get_fitness(nextx)
            if new_fitness < fitness:
                x = nextx
                fitness = new_fitness
                changed = True
                if logs < LOG_VALUES:
                    print("New value: %s at fitness %.4f" %
                          (terminal_repr(x), fitness))
                elif logs == LOG_VALUES:
                    print("...")
                logs += 1
                break

        # Random restart if necessary
        if not changed:
            x = random_string(10)
            fitness = get_fitness(x)
        iteration += 1

    print("Optimum at %s, fitness %.4f" % (terminal_repr(x), fitness))
```

```c
hillclimb_cgi_limited(100)
>Initial input: '埂\udf19\uf67c듵騛쁥핡勸\uf172싕' at fitness 3.0000
New value: '埂\udf19\uf67c듵騛쁥핡勷\uf172싕' at fitness 3.0000
New value: '埂\udf19\uf67c듵騛쁥핡勶\uf172싕' at fitness 3.0000
New value: '埂\udf19\uf67c듵騛쁥핡勵\uf172싕' at fitness 3.0000
New value: '埂\udf19\uf67c듵騛쁥핡勴\uf172싕' at fitness 3.0000
New value: '埂\udf19\uf67c듵騛쁥핡勳\uf172싕' at fitness 3.0000
New value: '埂\udf19\uf67c듵騛쁥핡勲\uf172싕' at fitness 3.0000
New value: '埂\udf19\uf67c듵騛쁥핡勱\uf172싕' at fitness 3.0000
New value: '埂\udf19\uf67c듵騛쁥핡勰\uf172싕' at fitness 3.0000
New value: '埂\udf19\uf67c듵騛쁥핡勯\uf172싕' at fitness 3.0000
New value: '埂\udf19\uf67c듵騛쁥핡勮\uf172싕' at fitness 3.0000
New value: '埂\udf19\uf67c듵騛쁥핡勭\uf172싕' at fitness 3.0000
New value: '埂\udf19\uf67c듵騛쁥핡勬\uf172싕' at fitness 3.0000
New value: '埂\udf19\uf67c듵騛쁥핡勫\uf172싕' at fitness 3.0000
New value: '埂\udf19\uf67c듵騛쁥핡勪\uf172싕' at fitness 3.0000
New value: '埂\udf19\uf67c듵騛쁥핡勩\uf172싕' at fitness 3.0000
New value: '埂\udf19\uf67c듵騛쁥핡勨\uf172싕' at fitness 3.0000
New value: '埂\udf19\uf67c듵騛쁥핡勧\uf172싕' at fitness 3.0000
New value: '埂\udf19\uf67c듵騛쁥핡勦\uf172싕' at fitness 3.0000
New value: '埂\udf19\uf67c듵騛쁥핡勥\uf172싕' at fitness 3.0000
New value: '埂\udf19\uf67c듵騛쁥핡勤\uf172싕' at fitness 3.0000
...
Optimum at '埂\udf19\uf67c듵騛쁥핡劔\uf172싕', fitness 3.0000
```

## Global Search

爬山者在搜索的每个步骤中都会探索一个人的本地邻域，如果邻域太大，那么这将花费很长时间。 一种替代策略是不将搜索限制在本地附近，而是全局搜索搜索空间。 也就是说，允许搜索算法在搜索空间内进行更大的调整。 对爬山者的简单修改即可将其从本地搜索算法转换为全局搜索算法：无需查看所有直接邻居，而是以允许进行较大修改的方式对进行了突变。

突变是一种变化，代表围绕搜索空间的较大步幅。 实施突变时，一个重要的决定是，从理论上讲，只需连续应用突变，就可以到达搜索空间中的任何点。 但是，突变通常不应完全用随机的个体代替个体。 对于该搜索而言，重要的是，该突变构成对仍然保留其大部分特征的个体的合理改变。 对于我们的10个字符字符串的搜索问题，可能的突变是在10个字符中仅替换 1 ，如下所示：

```c
def flip_random_character(s):
    pos = random.randint(0, len(s) - 1)
    new_c = chr(random.randrange(0, 65536))
    return s[:pos] + new_c + s[pos + 1:]
```

对爬山者的一个简单修改就是用突变代替对邻域的探索。 在每次迭代中，当前个体都会发生变异。 将生成的后代个体与其父代个体进行比较，两者中的更好者是搜索空间中的新点，并用于下一轮突变。 这称为“随机爬山”。

```c
def randomized_hillclimb():
    x = random_unicode_string(10)
    fitness = get_fitness(x)
    print("Initial value: %s at fitness %.4f" %
          (terminal_repr(x), fitness))

    iterations = 0
    while fitness > 0:
        mutated = flip_random_character(x)
        new_fitness = get_fitness(mutated)
        if new_fitness <= fitness:
            x = mutated
            fitness = new_fitness
            #print("New value: %s at fitness %.4f" %(terminal_repr(x), fitness))
        iterations += 1

    print("Optimum at %s after %d iterations" %
          (terminal_repr(x), iterations))
```

```c
randomized_hillclimb()

>Initial value: '舨ᑆ\uec4f\ue27f羏\uf314䖗繣厪킨' at fitness 2.9998
Optimum at 'ጤ〆撟%e5匸㗵暠ᴌ' after 34356 iterations
```

该算法通常比标准爬坡器更快地找到解决方案，尽管它仍然相当慢！

值得指出的是，爬山和随机版本之间有一个微妙但至关重要的变化：请注意比较new_fitness <= fitness，而在爬山中我们使用new_fitness < fitness。 这很重要，因为搜索范围可能具有适合度值（高原）相等的区域，我们需要以某种方式克服这些适合度值。 在标准的Hillcimber中，我们通过随机重启来完成此操作。 如果随机的爬山者拒绝适应度相同的后代，它将继续变异相同的个体，并可能难以摆脱高原。 如果我们也用相同的适应性替换，则允许搜索在高原上移动，最终增加逃脱的机会。

随机爬山者也称为 1 + 1进化算法（（1 + 1）EA ）。 进化算法是一种试图启发自然进化过程的元启发式搜索算法。 自然进化的基础是环境压力导致自然选择的种群：只有适者生存，而那些不适应者将死亡，因此种群的整体适应度逐渐提高。 （1 + 1）EA是一种非常特殊的进化算法，种群大小为1，可以精确地产生1个后代。 但是，实践中最常见的搜索算法是遗传算法。



## Genetic Algorithms

最著名的进化算法之一是*遗传算法*（GA）。 遗传算法的基础是问题解决方案可以通过基因编码：染色体由一系列基因组成，其中每个基因都编码一个人的一个特征（例如，眼睛的颜色，头发的颜色等）。 适应度函数可以获取此描述中包含的信息，即所谓的基因型，并评估所得表型的属性，即该遗传编码表示的实际解。 在表型上测量个体的适应性值。

对于我们的`cgi_decode()`示例，我们可以将单个字符视为基因，然后染色体是字符序列。 换句话说，到目前为止，我们已经使用了遗传编码！ 但是，对于GA来说，代表所需要的操作与邻居的枚举不同。

遗传算法通过以下过程模拟自然进化：

- 创建随机染色体的初始种群
- 选择适合的个体进行繁殖
- 通过选定个体的繁殖产生新的种群
- 继续这样做，直到找到最佳解决方案或达到其他限制。

创建初始种群的第一步很简单：

```
def create_population(size):
    return [random_unicode_string(10) for i in range(size)]
```



```
create_population(10)
```



```
['㛇莜戹豔㮝\ue008力ᒐᱯꊎ',
 '\ue295쁉陵ꯃ赖蟽⍬꺲緥㲱',
 '\u2e77騬⊳铁땕\uf189\ue663쌯幆艆',
 '龚筓\uf3a9욀놷䓒隯迌쀐∑',
 '쓛唁뗌蹽\udcd5偏躝娒鸭赌',
 '蹤⪖ឺ웳ఫ䓻䤷溸ᰒﵘ',
 '㲒혋Ꮘ\uea95\udf7b䢶裕㖬눹庑',
 '\u2d9d鼓咝笩窻ꨔ铺扄\ueb57\uf1bf',
 '\udd26Ч甄ꃢ\udcb0㼁튰㣋ช봼',
 '닇軬欴鞛㈓Ẫ住畿ꔪ칀']
```



选择过程偏向于更健康的个体，因此我们需要确定人口中所有个体的适应度值。 由于我们将在算法中的多个位置需要每个人的适应度值，因此我们要通过使适应度成为*元组*的列表来存储它，每个元组都由一个人及其适应度值组成。

```
def evaluate_population(population):
    fitness = [get_fitness(x) for x in population]
    return list(zip(population, fitness))
```



```
population = create_population(10)
```



```
for (individual, fitness) in evaluate_population(population):
    print("%s: %.4f" % (terminal_repr(individual), fitness))
```



```
'\ue46fت팣㘇ธ漅ೇ↪䜭㎮': 2.9994
'\ua7e9\ue9e0\ue7de턤댪囿厠‐\ue0c5ﴌ': 2.9999
'䇯Ꜩ잣\ua9ce㙦\uf4aa歿蘸ཎ㫜': 2.9997
'ⱳ콾哇\uef1f\uf6a8⾃䣖坤Ꮾ둰': 2.9998
'າ伫螉\ue110㝎겱괼䆵喞\u18ac': 2.9997
'ས婎쥤䇉韤\udd06䕮춵磒露': 2.9997
'辺緢噑粲\uf400嚳寬\x87ꐂ쑹': 2.9899
'뉫㻑\u1fd4㈖鬒樼\u0dcc朏\ue57eማ': 2.9997
'얨㐁皭់멄\ud97b\ueac9㢂ቅ뮜': 2.9998
'⒃⍜㈪㊷\udbdb乑蓍\udc48鱲뻜': 2.9999
```



在搜寻中使用适应性值通常是用“适者生存”来解释的，但达尔文对进化的主要见解之一是选择不仅取决于生存-个人通过性繁殖，而性选择描述了选择压力 在繁殖期间。 这种选择通常受以下两种情况之一的影响：竞争中的雄性为雌性而战，雄性（强力）获胜； 选择也受显示影响。 达尔文（Darwin）的例子就是孔雀：孔雀有长长而美丽的尾羽，似乎毫无用处，似乎也不支持自然选择的概念。 但是，豌豆的出现会影响其选择性伴侣的能力。 令人印象深刻的装饰品表明，男性在遗传上特别健康，并将导致健康的后代。 这在GA中得到了体现：一个人的适应度值越好，与另一个人交配的可能性就越大。 反映此概念的简单选择算法是*比赛选择*：少数随机选择的个人参加比赛，其中最好的被选中：

```
def selection(evaluated_population, tournament_size):
    competition = random.sample(evaluated_population, tournament_size)
    winner = min(competition, key=lambda individual: individual[1])[0]

    # Return a copy of the selected individual
    return winner[:]
```



`tournament_size`参数指定从总体中随机选择的个人中有多少人参加锦标赛。 这是一个重要的选择，因为它决定了*选择压力*：比赛规模越大，优秀个人被纳入比赛的可能性就越大。 反过来，这增加了这些非常好的个人支配下一代的可能性，从而降低了多样性并导致了过早的收敛。 相反，如果比赛的规模太小，那么这会阻碍比赛的进行。 锦标赛规模的最佳值取决于人口规模，但通常很小（例如5）。 让我们使用示例人群中的所有个体来运行一次锦标赛，以查看是否选择了最佳锦标赛：

```
population = create_population(10)
fitness = evaluate_population(population)
selected = selection(fitness, 10)
```



```
for (individual, fitness_value) in fitness:
    print("%s: %.4f" % (terminal_repr(individual), fitness_value))
```



```
'둚䘣蹸붢騒ꋎỺ觉\ued2a焊': 2.9999
'닔㶐ꡡ\udca4贕굇᳆\ueccd윘赉': 2.9999
'笁깉ရ豴\uea60ᛰ滒鶵）Ⰴ': 2.9998
'㠒㵄\ue14cᤃᇚ\udebe\uf851쿛鏆闊': 2.9998
'ࠝ\udd53ᶂ㮍訬廘랦铘뫘출': 2.9995
'ꡩၔ玤姨乪药汏䗫汔悔': 2.9998
'\uef2a潦ﳠ鹉卼㴐Ṭ\uf4b0˅얓': 2.9985
'❱\u0ff7╇塐䲫琭煸ᮤឋ퇃': 2.9998
'ڮ焈㱉煉ꅿᦗ툍혐خ꧓': 2.9994
'ἂጋ\uddcc\ue3d7粖\ude2c⮌鮓讃\ueab6': 2.9998
```



```
print("Winner: %s" % terminal_repr(selected))
```



```
Winner: '\uef2a潦ﳠ鹉卼㴐Ṭ\uf4b0˅얓'
```



就像在自然进化中一样，根据自己的健康状况选择的个体也可以繁殖，形成新一代。 在这种繁殖过程中，就像在自然繁殖过程中一样，所选亲本的遗传物质也会被合并。 这通常是通过称为 *crossover* 的过程完成的，其中后代染色体是由其父母的基因产生的。 在我们的例子中，一条染色体是一个字符序列，通过选择一个截止随机点，然后通过基于截止点组合父母染色体的两半来创建后代，可以简单地跨越两个父字符序列。

```
def crossover(parent1, parent2):
    pos = random.randint(1, len(parent1))

    offspring1 = parent1[:pos] + parent2[pos:]
    offspring2 = parent2[:pos] + parent1[pos:]

    return (offspring1, offspring2)
```



```
parent1 = "Hello World"
parent2 = "Goodbye Book"

crossover(parent1, parent2)
```



```
('Hello W Book', 'Goodbyeorld')
```



遗传进化的另一个重要组成部分是突变的概念：有时候，后代的基因会有细微的变化，代表着新的遗传物质和新的生理特性。 如果突变引入了代表有用特性的新遗传物质，从而导致了更好的适应性值，那么该遗传物质将生存。 如果该突变引入了无用的遗传物质，那么产生的个体将很可能具有不良适应性值并迅速死亡。

一个重要方面是，突变和交叉都是概率行为。 它们并不总是会发生，并且每次发生时其影响都是不同的。 对于序列遗传编码，一种常见的方法是首先使用概率来决定是否应用突变，然后选择一个基因并对其稍加更改。 或者，我们可以概率性地突变基因，使得平均一个基因发生改变。 我们通过计算每个基因被突变为1 /（基因数量）的概率`P`来做到这一点。 然后，如果基因发生突变，我们不仅会用随机字符代替它，而且更有可能只有很小的变化。 这是通过以当前值作为平均值从高斯分布中采样来实现的。 我们任意使用100的标准偏差来使小的变化比大的变化更有可能。

```
def mutate(chromosome):
    mutated = chromosome[:]
    P = 1.0 / len(mutated)

    for pos in range(len(mutated)):
        if random.random() < P:
            new_c = chr(int(random.gauss(ord(mutated[pos]), 100) % 65536))
            mutated = mutated[:pos] + new_c + mutated[pos + 1:]
    return mutated
```



现在，终于有了构成完整算法的所有要素：

```
def genetic_algorithm():
    # Generate and evaluate initial population
    generation = 0
    population = create_population(100)
    fitness = evaluate_population(population)
    best = min(fitness, key=lambda item: item[1])
    best_individual = best[0]
    best_fitness = best[1]
    print("Best fitness of initial population: %s - %.10f" %
        (terminal_repr(best_individual), best_fitness))
    logs = 0

    # Stop when optimum found, or we run out of patience
    while best_fitness > 0 and generation < 1000:

        # The next generation will have the same size as the current one
        new_population = []
        while len(new_population) < len(population):
            # Selection
            offspring1 = selection(fitness, 10)
            offspring2 = selection(fitness, 10)

            # Crossover
            if random.random() < 0.7:
                (offspring1, offspring2) = crossover(offspring1, offspring2)

            # Mutation
            offspring1 = mutate(offspring1)
            offspring2 = mutate(offspring2)

            new_population.append(offspring1)
            new_population.append(offspring2)

        # Once full, the new population replaces the old one
        generation += 1
        population = new_population
        fitness = evaluate_population(population)

        best = min(fitness, key=lambda item: item[1])
        best_individual = best[0]
        best_fitness = best[1]
        if logs < LOG_VALUES:
            print(
                "Best fitness at generation %d: %s - %.8f" %
                (generation, terminal_repr(best_individual), best_fitness))
        elif logs == LOG_VALUES:
            print("...")
        logs += 1

    print(
        "Best individual: %s, fitness %.10f" %
        (terminal_repr(best_individual), best_fitness))
```



让我们看看这在我们的unicode示例中如何工作。

```
genetic_algorithm()
```



```
Best fitness of initial population: '俴\x8a辰燄펧䬍缯檒㤢⦡' - 2.9901960784
Best fitness at generation 1: 'ཬə쫯ὼ酟剺鬈{Ż\ue313' - 2.98850575
Best fitness at generation 2: '俴\x82辰燄酟剺鬢\x1bŻ\ue313' - 2.90909091
Best fitness at generation 3: 'ྂɵ쫕ὼ酟剺鬈%Ŧ\ue384' - 1.99610895
Best fitness at generation 4: 'ྂɵ쬆ὼ酟剺鬈%ŋ\ue384' - 1.99565217
Best fitness at generation 5: '俴ʐ쫕ἶ酟剺髺%¼\ue384' - 1.98850575
Best fitness at generation 6: 'ྂɵ쫪ὼ酟剒鬈%\x9e\ue37f' - 1.98245614
Best fitness at generation 7: '俴̗쪕ἶ酟剺髱%4\ue378' - 0.99998280
Best fitness at generation 8: '侪\x86쪕ἶ酟剺髱%4\ue378' - 0.99998280
Best fitness at generation 9: '俆ǫ쪸ἶ醿剺髱%4\ue2b5' - 0.99998274
Best fitness at generation 10: '俆ǫ쪸ἶ釘剺髧%4\ue2b5' - 0.99998274
Best fitness at generation 11: '俆ɫ쫕Ồ酟剺髱%4\ue256' - 0.99998271
Best fitness at generation 12: '侪\x86쪕ἶ醿剺髱%4\ue1f9' - 0.99998268
Best fitness at generation 13: '侪ï쪕ἶ醿剺髱%4\ue1f9' - 0.99998268
Best fitness at generation 14: '俆\x86쪕ἶ醿剺髱%4\ue1f9' - 0.99998268
Best fitness at generation 15: '俆Ǩ쪸ἂ醿剺髱%4\ue150' - 0.99998263
Best fitness at generation 16: '俴ʓ쫕ớ鄞务髱%e\ue0f0' - 0.99998260
Best fitness at generation 17: '侪ï쪵ớ酟刖髱%F\ue0a9' - 0.99998258
Best fitness at generation 18: '佺ģ쪵ớ鄞劐髱%e\ue05c' - 0.99998256
Best fitness at generation 19: '侪ï쪵ớ酟刖髱%e\ue05c' - 0.99998256
Best fitness at generation 20: '侪ï쪵ί酃劐髝%e\ue00c' - 0.99998253
...
Best individual: '予ß쥇᳗轐咆隭%2A', fitness 0.0000000000
```



# Lessons Learned

- 启发式搜索问题由算法，表示形式和适应度函数组成
- 对于测试生成，适应度函数通常会估计执行到目标位置的距离。 为了确定该距离，我们使用插桩来计算测试执行期间的距离
- 当邻域定义良好且不太大时，像爬坡这样的本地搜索算法可以很好地工作。
- 全局搜索算法（例如遗传算法）非常灵活，可以很好地扩展到更大的测试问题



