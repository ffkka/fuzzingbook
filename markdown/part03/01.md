> 原文地址：https://www.fuzzingbook.org/html/Grammars.html

在[“基于突变的模糊检测”](https://github.com/apachecn/fuzzingbook-zh/blob/master/docs/MutationFuzzer.html) 一节中，介绍了如何使用额外的提示，比如示例输入文件，来加速测试用例生成过程。本节进一步拓展这个想法，通过提供程序合法输入的规范来指导fuzz过程。语法fuzz还是配置fuzz，API Fuzz，GUI Fuzz等领域的基础。



# Input Languages

程序的所有可能的行为都可以通过其输入来触发。 这里的“输入”可以有很多种可能的来源：从文件，环境或网络中读取的数据，用户输入的数据或通过与其他资源进行交互而获取的数据。 所有这些输入的集合决定了程序的行为方式。 因此，在测试时，考虑可能的输入源，这对如何控制它们以及如何系统地测试它们非常有帮助。

为了简单起见，现在假设该程序只有一个输入源； 这也是我们在前几章中一直使用的假设。 程序的有效输入集称为*语言*。 语言的范围从简单到复杂：CSV语言有效的逗号分隔输入的集合，而Python语言表示有效的Python程序集。 我们通常将数据语言和编程语言分开，尽管任何程序也可以视为输入数据（例如，对于编译器）。

为了规范的描述语言，形式语言领域已经设计了许多描述语言的语言规范。 正则表达式表示这些语言中表示字符串集的最简单的类：例如，正则表达式`[a-z]*`表示小写字母的序列。 自动机理论将这些语言与接受这些输入的自动机联系起来； 例如，有限状态机可用于指定正则表达式的语言。

> 看看就行，感兴趣的可以看编译原理

# Grammars

在正则表达式和图灵机之间的中间连接，由语法来填补。语法是形式化指定输入语言的最流行（也是最为理解的）形式之一。使用语法，可以表达语言的各种属性。语法特别适用于表达输入的语法结构，并且是表达嵌套或递归输入的首选形式。我们使用的语法称为`上下文无关文法`，这是最简单和最流行的语法形式之一。

## Rules and Expansions

语法由一个起始符号和一组扩展规则组成，这些规则指示起始符（以及其他符号）如何扩展。以一个示例为例，考虑以下语法，表示两个数字的序列

```c
<start> ::= <digit><digit>
<digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
```

要阅读这样的语法，从起始符号要阅读这样的语法，从起始符号`<start>`开始。扩展规则`<A> ::= <B>` 表示左侧的符号`<A>`可以被右侧的字符串`<B>`替换。在上面的语法中，`<start>`将被`<digit><digit>`替换。

在这个字符串中，`<digit>`将被右侧的字符串替换。特殊运算符|表示扩展的备选项（或简称备选项），意味着可以选择任何数字进行扩展。因此，每个`<digit>`将被扩展为给定的数字之一，最终生成一个在0和9之间的字符串。对于0到9，没有进一步的扩展，所以一切都准备好了。

有趣的是，语法可以是递归的。也就是说，扩展可以使用之前扩展过的符号，然后再次进行扩展。举个例子，考虑一个描述整数的语法：

```c
<start> ::= <integer> 
<integer> ::= <digit> | <digit><integer> 
<digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 
```

在这里，`<integer>`要么是一个单个数字，要么是一个数字后面跟着另一个整数。因此，数字1234可以表示为一个单个数字1，后面跟着整数234，而整数234又是数字2后面跟着整数34。

如果我们想表达整数可以以符号（+或-）开头，我们可以将语法写成：

```
<start> ::= <number> 
<number> ::= <integer> | +<integer> | -<integer> 
<integer> ::= <digit> | <digit><integer> 
<digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 
```

这些规则正式定义了语言：从起始符号派生出的任何内容都属于语言的一部分；不能派生出的则不属于语言。

### Arithmetic Expressions



